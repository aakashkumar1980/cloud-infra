package client_no_aws;

import company_backend.dto.DecryptRequest;
import company_backend.service.DecryptionService;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

import java.io.FileInputStream;
import java.io.InputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Company Backend Decryption Test (Use-Case 1 - Server Side)
 *
 * Tests the decryption service that runs on the company backend.
 * Uses AWS KMS to decrypt the DEK, then AES-GCM to decrypt the data.
 *
 * Flow:
 * 1. Read encrypted data from properties file (generated by ThirdPartyClientEncryptionTest)
 * 2. Call DecryptionService.decrypt() directly (no REST API)
 * 3. Verify decrypted data matches original
 *
 * Prerequisites:
 * - Run ThirdPartyClientEncryptionTest first to generate encryption-data.properties
 * - AWS credentials configured with access to KMS key
 */
@SpringBootTest(classes = company_backend.CompanyBackendApplication.class)
@ActiveProfiles("test")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class CompanyBackendDecryptionTest {

  private static final String PROPERTIES_FILE = "src/test/resources/_temp/encryption-data.properties";

  @Autowired
  private DecryptionService decryptionService;

  @Test
  @Order(1)
  @DisplayName("Full decryption flow - Read from properties and decrypt")
  void testFullDecryptionFlow() throws Exception {
    // === Step 1: Read encrypted data from properties file ===
    System.out.println("\n=== Step 1: Read Encrypted Data from Properties File ===");

    Path propsPath = Paths.get(PROPERTIES_FILE);
    Properties props = new Properties();
    try (InputStream is = new FileInputStream(propsPath.toFile())) {
      props.load(is);
    }

    String encryptedDek = props.getProperty("encryptedDek");
    String encryptedData = props.getProperty("encryptedData");
    String iv = props.getProperty("iv");
    String authTag = props.getProperty("authTag");
    String originalData = props.getProperty("originalData");

    assertNotNull(encryptedDek, "encryptedDek should not be null");
    assertNotNull(encryptedData, "encryptedData should not be null");
    assertNotNull(iv, "iv should not be null");
    assertNotNull(authTag, "authTag should not be null");
    assertNotNull(originalData, "originalData should not be null");

    System.out.println("✓ Loaded encryption data from: " + PROPERTIES_FILE);
    System.out.println("  Encrypted DEK (Base64): " + truncate(encryptedDek, 50));
    System.out.println("  Encrypted Data (Base64): " + truncate(encryptedData, 50));
    System.out.println("  IV (Base64): " + iv);
    System.out.println("  Auth Tag (Base64): " + authTag);

    // === Step 2: Call DecryptionService.decrypt() ===
    System.out.println("\n=== Step 2: Decrypt using DecryptionService ===");

    DecryptRequest request = new DecryptRequest(encryptedDek, encryptedData, iv, authTag);
    String decryptedData = decryptionService.decrypt(request);

    System.out.println("✓ Decryption successful");
    System.out.println("  Decrypted data: \"" + decryptedData + "\"");

    // === Step 3: Verify decrypted data matches original ===
    System.out.println("\n=== Step 3: Verify Result ===");

    assertEquals(originalData, decryptedData, "Decrypted data should match original");
    System.out.println("✓ SUCCESS: Decrypted data matches original!");
    System.out.println("  Original:  \"" + originalData + "\"");
    System.out.println("  Decrypted: \"" + decryptedData + "\"");
  }

  private String truncate(String str, int maxLen) {
    return str.length() > maxLen ? str.substring(0, maxLen) + "..." : str;
  }
}
